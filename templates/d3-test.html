<!DOCTYPE html>
<meta charset="utf-8">
<style>

#grouped-stacked-radio {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  position: absolute;
  left: 10px;
  top: 10px;
}

label {
  display: block;
}

</style>
<form id='grouped-stacked-radio'>
  <label><input type="radio" name="mode" value="grouped"> Grouped</label>
  <label><input type="radio" name="mode" value="stacked" checked> Stacked</label>
</form>
<svg width="960" height="500"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-queue.v3.min.js"></script>
<script src="https://code.jquery.com/jquery.js"></script>
<script>



// d3.json('/videoresults.json', makeGroupedStackedBarChart)
// function makeGroupedStackedBarChart(links) {

// d3.json("/videoresults.json", function(error, data) {

// LOADING MULTIPLE FILES //

d3.queue()
  .defer(d3.json, "/student-info.json")
  .defer(d3.json, "/examresults.json")
  .defer(d3.json, "/videoresults.json")
  .await(analyze);

function analyze(error, studentInfo, examResults, videoResults) {
  if (error) { console.log(error); }

  // PARSING JSON //
  var newStudentInfo = JSON.parse(studentInfo);
  console.log(newStudentInfo[0]);

  var newExamResults = JSON.parse(examResults);
  console.log(newExamResults[0]);

  var newVideoResults = JSON.parse(videoResults);
  console.log(newVideoResults[0]);

  // COMBINING DATA //

  newExamResults.forEach(function(newExamResults) {
    var result = newStudentInfo.filter(function(newStudentInfo) {
        return newStudentInfo.email === newExamResults.student_email;
    });
    // delete newExamResults.student_email;
    newExamResults.student_name = (result[0] !== undefined) ? result[0].nickname : null;
  });
  console.log(newExamResults);

  newVideoResults.forEach(function(newVideoResults) {
    var result = newStudentInfo.filter(function(newStudentInfo) {
        return newStudentInfo.email === newVideoResults.user;
    });
    // delete newVideoResults.user;
    newVideoResults.student_name = (result[0] !== undefined) ? result[0].nickname : null;
  });
  console.log(newVideoResults);

  newVideoResults.forEach(function(newVideoResults) {
    var result = newExamResults.filter(function(newExamResults) {
        return newExamResults.student_email === newVideoResults.user;
    });
    delete newVideoResults.user;
    newVideoResults.exam_id = (result[0] !== undefined) ? result[0].exam_id : null;
    newVideoResults.exam_score = (result[0] !== undefined) ? result[0].score : null;
  });

  var allResults = newVideoResults;
  console.log(allResults);

  displayD3(allResults);
}

var n = 3; // The number of series.
var m = 4; // The number of values per series.

function displayD3(dataArray){

  // The xz array has m elements, representing the x-values shared by all series.
  // The yz array has n elements, representing the y-values of each of the n series.
  // Each yz[i] is an array of m non-negative numbers representing a y-value for xz[i].
  // The y01z array has the same structure as yz, but with stacked [y₀, y₁] instead of y.

var examScores = [],
    videoPoints = [],
    videoSecondsWatched = [];

  for (i = 0; i < m; ++i) {
    examScores[i] = dataArray[i].exam_score;
  }
  console.log(examScores);

  for (i = 0; i < m; ++i) {
    videoPoints[i] = dataArray[i].points;
  }
  console.log(videoPoints);

  for (i = 0; i < m; ++i) {
    videoSecondsWatched[i] = dataArray[i].seconds_watched;
  }
  console.log(videoSecondsWatched);

var allResults = [examScores, videoPoints, videoSecondsWatched];


  // var exam_score = [],
  //     points = [],
  //     seconds_watched = [];

  // for (i = 0; i < m; ++i) {
  //   exam_score[i] = dataArray[i].exam_score;
  // }
  // console.log(exam_score);

  // for (i = 0; i < m; ++i) {
  //   points[i] = dataArray[i].points;
  // }
  // console.log(points);

  // for (i = 0; i < m; ++i) {
  //   seconds_watched[i] = dataArray[i].seconds_watched;
  // }
  // console.log(seconds_watched);

  var xz = d3.range(m),
      yz = d3.range(n).map(function() { return allResults; });
    console.log(yz);
  //     yz1 = d3.range(0).map(function() { return examScores; });
  // console.log(yz1);
  //     yz2 = d3.range(1).map(function() { return videoPoints; }),
  //     yz3 = d3.range(2).map(function() { return videoSecondsWatched; }),

      y01z = d3.stack().keys(d3.range(n))(d3.transpose(yz)),
      yMax = d3.max(yz, function(y) { return d3.max(y); }),
      y1Max = d3.max(y01z, function(y) { return d3.max(y, function(d) { return d[1]; }); });

  var svg = d3.select("svg"),
      margin = {top: 40, right: 10, bottom: 20, left: 10},
      width = +svg.attr("width") - margin.left - margin.right,
      height = +svg.attr("height") - margin.top - margin.bottom,
      g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  var x = d3.scaleBand()
      .domain(xz)
      .rangeRound([0, width])
      .padding(0.08);

  var y = d3.scaleLinear()
      .domain([0, y1Max])
      .range([height, 0]);

  var color = d3.scaleOrdinal()
      .domain(d3.range(n))
      .range(d3.schemeCategory20c);

  var series = g.selectAll(".series")
    .data(y01z)
    .enter().append("g")
      .attr("fill", function(d, i) { return color(i); });

  var rect = series.selectAll("rect")
    .data(function(d) { return d; })
    .enter().append("rect")
      .attr("x", function(d, i) { return x(i); })
      .attr("y", height)
      .attr("width", x.bandwidth())
      .attr("height", 0);

  rect.transition()
      .delay(function(d, i) { return i * 10; })
      .attr("y", function(d) { return y(d[1]); })
      .attr("height", function(d) { return y(d[0]) - y(d[1]); });

  g.append("g")
      .attr("class", "axis axis--x")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x)
          .tickSize(0)
          .tickPadding(6));

  d3.selectAll("input")
      .on("change", changed);

  var timeout = d3.timeout(function() {
    d3.select("input[value=\"grouped\"]")
        .property("checked", true)
        .dispatch("change");
  }, 2000);

  function changed() {
    timeout.stop();
    if (this.value === "grouped") transitionGrouped();
    else transitionStacked();
  }

  function transitionGrouped() {
    y.domain([0, yMax]);

    rect.transition()
        .duration(500)
        .delay(function(d, i) { return i * 10; })
        .attr("x", function(d, i) { return x(i) + x.bandwidth() / n * this.parentNode.__data__.key; })
        .attr("width", x.bandwidth() / n)
      .transition()
        .attr("y", function(d) { return y(d[1] - d[0]); })
        .attr("height", function(d) { return y(0) - y(d[1] - d[0]); });
  }

  function transitionStacked() {
    y.domain([0, y1Max]);

    rect.transition()
        .duration(500)
        .delay(function(d, i) { return i * 10; })
        .attr("y", function(d) { return y(d[1]); })
        .attr("height", function(d) { return y(d[0]) - y(d[1]); })
      .transition()
        .attr("x", function(d, i) { return x(i); })
        .attr("width", x.bandwidth());
  }

  // Returns an array of m psuedorandom, smoothly-varying non-negative numbers.
  // Inspired by Lee Byron’s test data generator.
  // http://leebyron.com/streamgraph/

}

// function bumps() {
//   var points = [];
//   var seconds_watched = [];

//   $.get("/videoresults.json", function(results){
//     var newResults = JSON.parse(results);
//     console.log(newResults);

//     for (i = 0; i < m; ++i) {
//       points[i] = newResults[i].points;
//     }

//     i = 0;
//     for (i = 0; i < m; ++i) {
//       seconds_watched[i] = newResults[i].seconds_watched;
//     }

//     var data = [points, seconds_watched];
//     console.log(data);
//     displayD3(data);
//   })
// }

// bumps();

  // function bumps(m) {
  //   // debugger;
  //   var values = [];

  //   // Initialize with uniform random values in [0.1, 0.2).
  //   for (i = 0; i < m; ++i) {
  //     values[i] = 0.1 + 0.1 * Math.random();
  //   }
  //   console.log(values);

  //   // Add five random bumps.
  //   for (j = 0; j < 5; ++j) {
  //     x = 1 / (0.1 + Math.random());
  //     y = 2 * Math.random() - 0.5;
  //     z = 10 / (0.1 + Math.random());
  //     for (i = 0; i < m; i++) {
  //       w = (i / m - y) * z;
  //       values[i] += x * Math.exp(-w * w);
  //     }
  //   }

  //   // Ensure all values are positive.
  //   for (i = 0; i < m; ++i) {
  //     // values[i] = i*i;
  //     values[i] = Math.max(0, values[i]);
  //   }

  //   console.log(values);
  //   return values;
  // }
// })

</script>